oauth2-proxy:
  config:
    existingSecret: phoenixchartmain-oauth2-secrets
    configFile: |
      # Settings for Auth0
      provider="oidc"
      provider_display_name="Auth0"
      oidc_issuer_url="https://dev-2ii4bfcaymdes14b.uk.auth0.com/"
      code_challenge_method="S256"
      http_address="0.0.0.0:4180"
      upstreams="file:///dev/null"
      email_domains="*"
      # Important that this machtes the domain being used for the cluster
      cookie_domains=".phoenix.local"
      whitelist_domains=["*.phoenix.local:*", "dev-2ii4bfcaymdes14b.uk.auth0.com"]
      # email is needed as is not in default openid scrop
      scope="openid email"
      pass_access_token = true
      pass_authorization_header = true
      pass_user_headers = true
      set_xauthrequest = true
      # To remove when secure version is used
      show_debug_on_error = true
      insecure_oidc_allow_unverified_email = true
      ssl_insecure_skip_verify=true
      cookie_secure="false"
superset:
  enabled: true
  # These secrets must be created before the first apply of the chart
  envFromSecret: phoenixchartmain-superset-env-override
  postgresql:
    auth:
      # This is needed to override the postgresql passwords
      existingSecret: phoenixchartmain-superset-env-override
  configOverrides:
    proxy_override: |
      # This will make sure the redirect_uri is properly computed, even with SSL offloading
      ENABLE_PROXY_FIX = True
      SESSION_COOKIE_SAMESITE = None
      SESSION_COOKIE_SECURE = False
      SESSION_COOKIE_HTTPONLY = False
      WTF_CSRF_ENABLED = False
      TALISMAN_ENABLED=False
    user_login_via_headers: |
      # This is a temporary override of the security for superset so that the user email
      # is gotten from the header: x-auth-request-email
      # Currently a admin user will be created if it is not found but this should be change
      # in the future
      from flask_appbuilder.security.manager import AUTH_REMOTE_USER
      AUTH_TYPE = AUTH_REMOTE_USER
      AUTH_REMOTE_USER_ENV_VAR = "x-auth-request-email"
      # Will allow user self registration, allowing to create Flask users from Authorized User
      AUTH_USER_REGISTRATION = True
      # The default user self registration role
      AUTH_USER_REGISTRATION_ROLE = "Admin"

      import logging
      from flask_appbuilder.security.views import AuthView
      from flask_appbuilder.views import expose
      from werkzeug.wrappers import Response as WerkzeugResponse
      from flask import abort, current_app, flash, g, redirect, request, session, url_for
      from superset.security import SupersetSecurityManager
      from flask_login import login_user, logout_user
      from flask_appbuilder.utils.base import get_safe_redirect, lazy_formatter_gettext
      from flask_appbuilder.const import LOGMSG_WAR_SEC_LOGIN_FAILED

      class AutheRemoteUserViewCustom(AuthView):
          login_template = ""

          @expose("/login/")
          def login(self) -> WerkzeugResponse:
              logging.info("HELLO")
              username = request.headers.get("x-auth-request-email")
              logging.info(username)
              if username:
                  logging.info("GETTING USER")
                  user = self.appbuilder.sm.auth_user_remote_user(username)
                  logging.info(user)
                  if user is None:
                      flash(as_unicode(self.invalid_login_message), "warning")
                  else:
                      login_user(user)
              else:
                  flash(as_unicode(self.invalid_login_message), "warning")
              next_url = request.args.get("next", "")
              return redirect(get_safe_redirect(next_url))


      class CustomSsoSecurityManager(SupersetSecurityManager):
          authremoteuserview = AutheRemoteUserViewCustom
          def auth_user_remote_user(self, username):
            """
            REMOTE_USER user Authentication

            :param username: user's username for remote auth
            :type self: User model
            """
            email = username
            user = self.find_user(email=email)
            logging.info("FOUND USER")
            logging.info(user)

            # User does not exist, create one if auto user registration.
            if user is None and self.auth_user_registration:
                logging.info("CREATING USER")
                user = self.add_user(
                    username="some_user" + email,
                    first_name="remote_user",
                    last_name="-",
                    email=email,
                    role=self.find_role(self.auth_user_registration_role),
                )

            # If user does not exist on the DB and not auto user registration,
            # or user is inactive, go away.
            elif user is None or (not user.is_active):
                logging.info("CHECK", username)
                return None

            self.update_user_auth_stat(user)
            return user

      CUSTOM_SECURITY_MANAGER = CustomSsoSecurityManager
